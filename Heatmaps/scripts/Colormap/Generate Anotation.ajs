// /*
//  * ----------------------------------------------------------------------------
//  * Script: Heatmap Colour Wizard for ArchiMate Views
//  * Tool: jArchi
//  *
//  * Description:
//  *   Provides a UI-based wizard to generate heatmaps on ArchiMate views by
//  *   applying fill colours based on element property values.
//  *   Supports:
//  *     - Gathering property values from a selected element type
//  *     - Applying colour schemes to matching elements
//  *     - Automatically generating a visual legend
//  *
//  * Ownership: Property of BHP
//  * Author   : Santos, Nico
//  * Version  : 1.0
//  * Last Updated: 2025-06-10
//  * ----------------------------------------------------------------------------
//  */

// if (typeof __CALLER_SCRIPT__ == "undefined") {
//   // it is the main script
//   load(__SCRIPTS_DIR__ + "Heatmaps/lib/misc.js");
//   log.level = LogLevel.INFO;
//   if (log.level <= LogLevel.DEBUG) {
//     console.clear();
//     console.show();
//   }
// }

// load(__SCRIPTS_DIR__ + "Heatmaps/lib/colormap/Model.js");
// load(__SCRIPTS_DIR__ + "Heatmaps/lib/colormap/UI.js");

// function getElement(view) {
//   const element_text = "element";
//   const general_text = "All element types";
//   let elements = $(view).find(element_text);
//   let elementTypes = [general_text]; // Start with default option
//   let seenTypes = new Set(); // Track unique element types
//   let selectedType;

//   elements.forEach((el) => {
//     if (!el.type || seenTypes.has(el.type)) return;
//     seenTypes.add(el.type);
//     elementTypes.push(el.type);
//   });

//   const selected = window.promptSelection(
//     "Select an element type from the view:",
//     elementTypes,
//     0
//   );
//   if (!selected) {
//     console.log("No element selected.");
//     exit();
//   }

//   selectedType = selected === general_text ? element_text : selected;

//   console.log("Selected element type: " + selectedType);
//   return selectedType;
// }

// function createAnnotationInside(el, text) {
//   // sets the size and position of the annotation
//   const SIZE = 25;
//   const x = 95;
//   const y = 30;

//   const group = el.createObject("note", x, y, SIZE, SIZE);

//   group.name = text;
//   group.fillColor = "#E0E0E0";
//   group.borderType = BORDER.RECTANGLE;
//   group.fontStyle = "italic";

//   // el.view().bringToFront(group);

//   console.log(`Annotation added inside: ${el.name}`);
// }

// /**
//  * Will gather all properties of all elements visual objects in the view (no relationships)
//  * and for each property, the set of found values
//  * 
//  * MAYBE: extend to support relationship schemes?
//  * 
//  * @param {ArchimateView} view the view to gather from
//  * @param {string} [property] collect only for this property
//  * @returns {{[x:string]: string[]}} alphabetically ordered property names and associated labels
//  */
// function gatherViewPropertiesInfo(view, property = undefined) {
//     /** 
//      * @type {Map<string,Set<string>>} 
//      */
//     const props = new Map();
//     let element_type = String(getElement(view));
//     if (!element_type) {
//         log.error("No element type selected, stopping");
//         // MessageDialog.openError(shell, "No element type", "No element type selected. Stopping.");
//         exit();
//     }
//     $(view).find(element_type).each (
//         (e) => {
//             for (let p of e.prop()) {
//                 if (property === undefined || p === property) {
//                     if (!props.has(p)) {
//                         props.set(p, new Set());
//                     }
//                     props.get(p).add(e.prop(p));
//                 }
//             }
//         }
//     )
//     // sorting alphabetically by property names and labels (as Array)
//     const result = Object.fromEntries([...props.entries()].sort().map(([pname, labels]) => [pname, [...labels].sort()]));
//     log.trace('collected:' + JSON.stringify(result, null, 2));
//     if (Object.keys(result).length == 0) {
//         console.log("Exiting");
//         exit();
//     }
//     return result;
// }

// function run_main() {
//   const view = getCurrentView();

//   const propertyMap = gatherViewPropertiesInfo(view);
//   const propertyNames = Object.keys(propertyMap);

//   if (propertyNames.length === 0) {
//     console.log("No properties found in the view.");
//     exit();
//   }

//   const selectedProperty = window.promptSelection(
//     "Select a property to annotate:",
//     propertyNames,
//     0
//   );

//   if (!selectedProperty) {
//     console.log("No property selected.");
//     exit();
//   }

//   // Annotate all elements with the selected property's value
//   // const elementType = getElement(view);
//   // const elements = $(view).find(elementType);

//   // elements.forEach(el => {
//   //   const value = el.prop(selectedProperty) || "(no value)";
//   //   createAnnotationInside(el, value);
//   // });

//   // console.log(`Annotated ${elements.length} elements with property '${selectedProperty}'.`);
// }


// run_main();


/* 
 * ----------------------------------------------------------------------------
 * Script: Heatmap Colour Wizard for ArchiMate Views
 * Tool: jArchi
 * 
 * Description:
 *   Provides a UI-based wizard to generate heatmaps on ArchiMate views by
 *   applying fill colours based on element property values.
 *   Supports:
 *     - Gathering property values from a selected element type
 *     - Applying colour schemes to matching elements
 *     - Automatically generating a visual legend
 * 
 * Ownership: Property of BHP
 * Author   : Santos, Nico
 * Version  : 1.0
 * Last Updated: 2025-06-10
 * ----------------------------------------------------------------------------
 */


if (typeof __CALLER_SCRIPT__ == 'undefined') {
    // it is the main script
    load(__SCRIPTS_DIR__ + "Heatmaps/lib/misc.js");
    log.level = LogLevel.INFO;
    if (log.level <= LogLevel.DEBUG) {
        console.clear();
        console.show();
    }
}

load(__SCRIPTS_DIR__ + "Heatmaps/lib/colormap/Model.js")
load(__SCRIPTS_DIR__ + "Heatmaps/lib/colormap/UI.js")

// name of the property stored in view referencing the Archimate selected property for colormap
const COLORMAP_PROPERTY = ".colormap.property";

/**
 * Will gather all properties of all elements visual objects in the view (no relationships)
 * and for each property, the set of found values
 * 
 * MAYBE: extend to support relationship schemes?
 * 
 * @param {ArchimateView} view the view to gather from
 * @param {string} [property] collect only for this property
 * @returns {{[x:string]: string[]}} alphabetically ordered property names and associated labels
 */
function gatherViewPropertiesInfo(view, property = undefined, selected_element_type) {
    /** 
     * @type {Map<string,Set<string>>} 
     */
    const props = new Map();
    let element_type = selected_element_type;
    if (!element_type) {
        log.error("No element type selected, stopping");
        // MessageDialog.openError(shell, "No element type", "No element type selected. Stopping.");
        exit();
    }
    $(view).find(element_type).each (
        (e) => {
            for (let p of e.prop()) {
                if (property === undefined || p === property) {
                    if (!props.has(p)) {
                        props.set(p, new Set());
                    }
                    props.get(p).add(e.prop(p));
                }
            }
        }
    )
    // sorting alphabetically by property names and labels (as Array)
    const result = Object.fromEntries([...props.entries()].sort().map(([pname, labels]) => [pname, [...labels].sort()]));
    log.trace('collected:' + JSON.stringify(result, null, 2));
    if (Object.keys(result).length == 0) {
        console.log("Exiting");
        exit();
    }
    return result;
}

/**
 * Apply to the view the heatmap as configured by the wizard
 * @param {ArchimateView} view 
 * @param {ColorScheme} scheme
 */

// TODO: check if the note already exists inside the element. Place the position next to existing one.
// TODO: Legend should reuse the existing legend if it exists (object_state: "legend")
function applyColorScheme(view, scheme, selectedType = "element") {
    const SIZE = 25;
    const CHAR_WIDTH = 8;

    $(view).find(selectedType).each((vo) => {
        const label = vo.prop(scheme.name);
        if (label && (label in scheme.colormap)) {
            const color = scheme.colormap[label];

            let noteWidth = SIZE;
            let noteText = "";
            let x = 95;
            let y = 30;

            if (Wizard.annotationEnabled) {
                noteText = label;
                noteWidth = label.length * CHAR_WIDTH;

                const bounds = vo.bounds;
                const maxX = bounds.width - noteWidth;
                const maxY = bounds.height - SIZE;

                x = Math.max(5, Math.min(95, maxX));
                y = Math.max(5, Math.min(30, maxY));
            }

            const note = vo.createObject("diagram-model-note", x, y, noteWidth, SIZE);
            const elementType = vo.type;
            const propertyName = scheme.name;
            const elementName = vo.name || "unnamed";
            const noteId = `${elementType}-${propertyName}-${elementName}`;

            note.prop("note-id", noteId);
            note.text = noteText;
            note.fillColor = color;
            note.fontStyle = "bold";
            note.borderType = BORDER.RECTANGLE;
        }
    });
}


function getElement(view) {
  const element_text = "element";
  const general_text = "All element types";
  let elements = $(view).find(element_text);
  let elementTypes = [general_text]; // Start with default option
  let seenTypes = new Set(); // Track unique element types
  let selectedType;

  elements.forEach((el) => {
    if (!el.type || seenTypes.has(el.type)) return;
    seenTypes.add(el.type);
    elementTypes.push(el.type);
  });

  const selected = window.promptSelection("Select an element type from the view:", elementTypes, 0);
  if (!selected) {
    console.log("No element selected.");
    exit();
  }

  selectedType = selected == general_text ? element_text : selected;

  console.log("Selected element type: " + selectedType);
  return selectedType;
}

/**
 * Replace or create the associated legend in the view
 * @param {ArchimateView} view 
 * @param {ColorScheme} scheme 
 */
// function createLegend(view, scheme) {
//     const GRID_SIZE = 12;
//     const X_MARGIN = GRID_SIZE / 2;
//     const Y_MARGIN = GRID_SIZE / 2;
//     const COLOR_HEIGHT = 30;
//     const COLOR_WIDTH = 12 * GRID_SIZE;
    
//     let X_LEGEND_ORIGIN = GRID_SIZE;
//     let Y_LEGEND_ORIGIN = GRID_SIZE;
//     const LEGEND_WIDTH = 2 * X_MARGIN + COLOR_WIDTH + scheme.name.length;
//     const LEGEND_NAME = "Color Legend";
//     const LEGEND_BACKGROUND = "#F7F7F7";
//     const LEGEND_FONT_STYLE = "bold";

//     const isCategorical = scheme.type == "Categorical";
//     const spacing = (isCategorical) ? Y_MARGIN : 0;

//     const currentLegend = $(view).find("." + LEGEND_NAME).filter("diagram-model-group").first();
//     if (currentLegend && scheme.resetDefault) {
//         log.info(`previous ${LEGEND_NAME} found, deleting`)
//         X_LEGEND_ORIGIN = currentLegend.bounds.x; 
//         Y_LEGEND_ORIGIN = currentLegend.bounds.y;
//         currentLegend.delete();
//     }
//     const legendGroup = view.createObject(
//         "diagram-model-group", X_LEGEND_ORIGIN, Y_LEGEND_ORIGIN, LEGEND_WIDTH, 
//             COLOR_HEIGHT + (COLOR_HEIGHT + spacing) * Object.keys(scheme.colormap).length + spacing
//         );
//     legendGroup.name = LEGEND_NAME;
//     legendGroup.fillColor = LEGEND_BACKGROUND;
//     legendGroup.fontStyle = LEGEND_FONT_STYLE
//     legendGroup.borderType = BORDER.RECTANGLE;

//     let y = COLOR_HEIGHT;
//     const colormap = Object.entries(scheme.colormap);
//     colormap.sort(isCategorical ? undefined : (a, b) => parseFloat(a[0]) - parseFloat(b[0]));
//     for (const [label, color] of colormap) {
//         log.trace(`legend label '${label}' color = ${color}`);
//         let colLegend = legendGroup.createObject("diagram-model-note", X_MARGIN, y, COLOR_WIDTH + scheme.name.length, COLOR_HEIGHT);
//         y += COLOR_HEIGHT + spacing -1;
//         colLegend.fillColor = color;
//         colLegend.borderType = isCategorical ? BORDER.RECTANGLE : BORDER.NONE;
//         colLegend.text = scheme.name + " = " + label;
//     }

// }
// function createLegend(view, scheme) {
//     const GRID_SIZE = 12;
//     const X_MARGIN = GRID_SIZE / 2;
//     const Y_MARGIN = GRID_SIZE / 2;
//     const COLOR_HEIGHT = 30;
//     const COLOR_WIDTH = 12 * GRID_SIZE;

//     let X_LEGEND_ORIGIN = GRID_SIZE;
//     let Y_LEGEND_ORIGIN = GRID_SIZE;
//     const LEGEND_WIDTH = 2 * X_MARGIN + COLOR_WIDTH + scheme.name.length;
//     const LEGEND_NAME = "Color Legend";
//     const LEGEND_BACKGROUND = "#F7F7F7";
//     const LEGEND_FONT_STYLE = "bold";

//     const isCategorical = scheme.type == "Categorical";
//     const spacing = (isCategorical) ? Y_MARGIN : 0;

//     // Find existing legend by object_state property
//     let legendGroup = $(view)
//         .filter("diagram-model-group")
//         .filter(obj => obj.prop("object_state") === "legend")[0];

//     if (!legendGroup) {
//         const currentLegend = $(view).find("." + LEGEND_NAME).filter("diagram-model-group").first();
//         if (currentLegend && scheme.resetDefault) {
//             log.info(`previous ${LEGEND_NAME} found, deleting`);
//             X_LEGEND_ORIGIN = currentLegend.bounds.x;
//             Y_LEGEND_ORIGIN = currentLegend.bounds.y;
//             currentLegend.delete();
//         }

//         legendGroup = view.createObject(
//             "diagram-model-group", X_LEGEND_ORIGIN, Y_LEGEND_ORIGIN, LEGEND_WIDTH,
//                 COLOR_HEIGHT + (COLOR_HEIGHT + spacing) * Object.keys(scheme.colormap).length + spacing
//         );
//         legendGroup.name = LEGEND_NAME;
//         legendGroup.fillColor = LEGEND_BACKGROUND;
//         legendGroup.fontStyle = LEGEND_FONT_STYLE;
//         legendGroup.borderType = BORDER.RECTANGLE;
//         legendGroup.prop("object_state", "legend"); // ✅ NEW: Tag as legend
//     }

//     let y = COLOR_HEIGHT;
//     const colormap = Object.entries(scheme.colormap);
//     colormap.sort(isCategorical ? undefined : (a, b) => parseFloat(a[0]) - parseFloat(b[0]));

//     for (const [label, color] of colormap) {
//         log.trace(`legend label '${label}' color = ${color}`);
//         const CHAR_WIDTH = 8;
//         let noteText = scheme.name + " = " + label;
//         let noteWidth = noteText.length * CHAR_WIDTH;

//         // note for legend
//         let colLegend = legendGroup.createObject(
//             "diagram-model-note", 
//             X_MARGIN, 
//             y, 
//             noteWidth, 
//             COLOR_HEIGHT
//         );

//         y += COLOR_HEIGHT + spacing - 1;
//         colLegend.fillColor = color;
//         colLegend.borderType = isCategorical ? BORDER.RECTANGLE : BORDER.NONE;
//         colLegend.text = scheme.name + " = " + label;

//         log.info(`Legend group size: width = ${legendGroup.bounds.width}, height = ${legendGroup.bounds.height}`);
//         log.info(`Legend group size: width = ${legendGroup.bounds.width}, height = ${legendGroup.bounds.height}`);

//     }
// }

function createLegend(view, scheme) {
    const GRID_SIZE = 12;
    const X_MARGIN = GRID_SIZE / 2;
    const Y_MARGIN = GRID_SIZE / 2;
    const COLOR_HEIGHT = 30;
    const COLOR_WIDTH = 12 * GRID_SIZE;

    let X_LEGEND_ORIGIN = GRID_SIZE;
    let Y_LEGEND_ORIGIN = GRID_SIZE;
    const LEGEND_NAME = "Color Legend";
    const LEGEND_BACKGROUND = "#F7F7F7";
    const LEGEND_FONT_STYLE = "bold";

    const isCategorical = scheme.type == "Categorical";
    const spacing = (isCategorical) ? Y_MARGIN : 0;

    // Calculate max width based on label text
    const CHAR_WIDTH = 6;
    let maxLabelWidth = 0;
    for (const [label] of Object.entries(scheme.colormap)) {
        const text = scheme.name + " = " + label;
        const width = text.length * CHAR_WIDTH;
        if (width > maxLabelWidth) maxLabelWidth = width;
    }
    const LEGEND_WIDTH = 2 * X_MARGIN + maxLabelWidth;

    // Find existing legend by object_state property
    let legendGroup = $(view)
        .filter("diagram-model-group")
        .filter(obj => obj.prop("Object State") === "legend")[0];

    if (!legendGroup) {
        const currentLegend = $(view).find("." + LEGEND_NAME).filter("diagram-model-group").first();
        if (currentLegend && scheme.resetDefault) {
            log.info(`previous ${LEGEND_NAME} found, deleting`);
            X_LEGEND_ORIGIN = currentLegend.bounds.x;
            Y_LEGEND_ORIGIN = currentLegend.bounds.y;
            currentLegend.delete();
        }

        legendGroup = view.createObject(
            "diagram-model-group", X_LEGEND_ORIGIN, Y_LEGEND_ORIGIN, LEGEND_WIDTH,
                COLOR_HEIGHT + (COLOR_HEIGHT + spacing) * Object.keys(scheme.colormap).length + spacing
        );
        legendGroup.name = LEGEND_NAME;
        legendGroup.fillColor = LEGEND_BACKGROUND;
        legendGroup.fontStyle = LEGEND_FONT_STYLE;
        legendGroup.borderType = BORDER.RECTANGLE;
        legendGroup.prop("object_state", "legend");
    }

    let y = COLOR_HEIGHT;
    const colormap = Object.entries(scheme.colormap);
    colormap.sort(isCategorical ? undefined : (a, b) => parseFloat(a[0]) - parseFloat(b[0]));

    for (const [label, color] of colormap) {
        log.trace(`legend label '${label}' color = ${color}`);
        let noteText = scheme.name + " = " + label;
        let noteWidth = noteText.length * CHAR_WIDTH;

        // note for legend
        let colLegend = legendGroup.createObject(
            "diagram-model-note", 
            X_MARGIN, 
            y, 
            noteWidth, 
            COLOR_HEIGHT
        );

        y += COLOR_HEIGHT + spacing - 1;
        colLegend.fillColor = color;
        colLegend.borderType = isCategorical ? BORDER.RECTANGLE : BORDER.NONE;
        colLegend.text = scheme.name + " = " + label;

    }
}


/**
 * The Wizard main
 * 
 * @param {JavaObject} view the view to work on
 * @param {boolean} openView open the view in UI (NIY)
 * @returns {boolean} true if wizard successful, false if prematurely terminated
 */
function colorWizard(view, openView = false) {
    // const dir = __SCRIPTS_DIR__ + 'Heatmaps/lib/colormap/scheme';
    // if (!mkdirs(dir)) {
    //     MessageDialog.openWarning(shell, "Color scheme saving", `Cannot create directory '${dir}' for storing color scheme.\nWon't be able to save them for default colors.`);
    //     log.warn(`Not possible to create directory '${dir}' for storing color scheme`);
    // }
    let selected_element_type = getElement(view);
    
    if (openView) {
        // show the view in case it is called from reapply on model
        // view.openInUI() no api in jscript ;-(
    }

    const scheme = Wizard.execute(gatherViewPropertiesInfo(view, undefined, selected_element_type), undefined, "generate-annotation");
    // console.log("ITS the SCHEME!!! " + JSON.stringify(scheme, null, 2));
    if (scheme) {
        log.debug(`scheme = ${JSON.stringify(scheme, null, 2)}`)
        applyColorScheme(view, scheme, selected_element_type);
        createLegend(view, scheme);
        return true
    } else {
        log.warn("execution cancelled");
        return false
    }
}

if (typeof __CALLER_SCRIPT__ != 'undefined') {
    log.trace(`${__FILE__} loaded as a library for '${__CALLER_SCRIPT__}'`)
} else {
    log.info("*** Colormap: Wizard - start")
    const theView = getCurrentView();
    colorWizard(theView);
    log.info("*** Colormap: Wizard - end.");
}

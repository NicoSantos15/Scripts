//
// Generate diagram legend
//
// For a selected view, create a group named 'Legend', in which will be nested for each concepts type found in view
// - a concept, specifically sized to show the pictogram
// - a note, to be used to name or explain the concept specifically in the view, hence preventing to rename the concept
// That way,
// - a model will be a bit polluted but with a specific set of concepts, for legend purpose, prefixed so easily identifiable
// - the same set can be used in multiple views, multiples legends as the associated text is set in a side note
//
// Roadmap:
// - ask to delete an existing group name 'Legend' before create a new group
// - improve typesList cleaning (removing types not concerned by legend) to avoid adding an exception
//

var x = 10;
var y = 10;
var default_width = 50;
var default_height = 30;
var typesList = [];
var pictogram_x = x + 10;
var label_x = x + pictogram_x + 30;
var label_width = default_width + 80;
var groupWidth = 10 + default_width + 10 + label_width + 10;
var groupHeight = default_height + y;
var prefix = "legend-purpose-";
var groupName = "Legend";
var noteFigureType = 0;
var noteOpacity = 0;
var noteOutlineOpacity = 0;

// Folders to be created if not exist
var businessFolder, 
    strategyFolder,
    applicationFolder,
    technologyFolder,
    motivationFolder,
    implementationFolder,
    otherFolder,
    relationsFolder;

// Types to exclude from the legend
var excludedTypes = [
  "diagram-model-group",
  "diagram-model-note",
  "diagram-model-connection",
  "archimate-diagram-model"
];

// const folders = {
//     business: "Business-Legends",
//     strategy: "Strategy-Legends",
//     application: "Application-Legends",
//     technology: "Technology-Legends",
//     motivation: "Motivation-Legends",
//     implementation: "Implementation-Legends",
//     other: "Other-Legends",
//     relations: "Relations-Legends"
// };

console.show();
console.clear();
console.log("> Generate diagram legend:");

function onlyUnique(value, index, self) {
  return self.indexOf(value) === index;
}

// Generate a folder if it does not exist
function generateFolder(parentFolder, nameSuffix) {
  var folderName = parentFolder.name + nameSuffix;
  var existing = $("folder." + folderName).first();
  if (!existing) {
    console.log("> Creating folder: " + folderName);
    var newFolder = parentFolder.createFolder(folderName);
    newFolder.prop("Object State", groupName);
    return newFolder
  }
}

var currentView = $(selection).filter("archimate-diagram-model").first();
if (!currentView) {
  console.log("> No view identified: exiting.");
  exit();
}

// (1) Create the Grouping element at the model level
var groupingElement = model.createElement("grouping", "My Grouping Element");

// (2) Add it visually to your view
var groupingViewObject = currentView.add(groupingElement, 100, 100, 200, 120);

// (Optional) Customize ii appearance
groupingViewObject.name = "";
console.log(groupingViewObject);
groupingViewObject.image = "";
groupingViewObject.outlineOpacity = 0;

// Create a legend folder if not exist
// var otherFolder = $("folder.Other").first();
// var legendFolder = $("folder.Legend").first();
// if (!legendFolder) {
//   otherFolder.createFolder("Legend"); 
//   console.log("> No Legend folder detected. Legend Folder Created");
// }else{
//   // console.log("Legend Folder Exists");
// }

businessFolder = $("folder.Business").first();
strategyFolder = $("folder.Strategy").first();
applicationFolder = $("folder.Application").first();
technologyFolder = $("folder.Technology & Physical").first();
motivationFolder = $("folder.Motivation").first();
implementationFolder = $("folder.Implementation & Migration").first();
otherFolder = $("folder.Other").first();
relationsFolder = $("folder.Relations").first();

// Go through each folder type
generateFolder(businessFolder, groupName);
generateFolder(strategyFolder, groupName)
generateFolder(applicationFolder, groupName)
generateFolder(technologyFolder, groupName)
generateFolder(motivationFolder, groupName)
generateFolder(implementationFolder, groupName)
generateFolder(otherFolder, groupName)
generateFolder(relationsFolder, groupName)

// businessFolder.createFolder(groupName + "-" + businessFolder.name);
// strategyFolder.createFolder(groupName + "-" + strategyFolder.name);
// applicationFolder.createFolder(groupName + "-" + applicationFolder.name);
// technologyFolder.createFolder(groupName + "-" + technologyFolder.name);
// motivationFolder.createFolder(groupName + "-" + motivationFolder.name);
// implementationFolder.createFolder(groupName + "-" + implementationFolder.name);

// otherFolder.createFolder(groupName + "-" + otherFolder.name);

// This is a terrible way to get the name of the folder

// businessFolderObj = $(groupName + "-" + businessFolder.name + "-Folder").first();
// strategyFolderObj = $(groupName + "-" + strategyFolder.name + "-Folder").first();
// applicationFolderObj = $(groupName + "-" + applicationFolder.name + "-Folder").first();
// technologyFolderObj = $(groupName + "-" + technologyFolder.name + "-Folder").first();
// motivationFolderObj = $(groupName + "-" + motivationFolder.name + "-Folder").first();
// implementationFolderObj = $(groupName + "-" + implementationFolder.name + "-Folder").first();
// otherFolderObj = $(groupName + "-" + otherFolder.name + "-Folder").first();


// testingChildren = businessFolder.children().each(function(f){
//   console.log(f)
// })

// var mySubfolder = businessFolder.folders.filter(function(f) {
//   console.log(f)
//   return f.name === "Legend";
// }).first();

// Loop through all elements used in selected view and push into array elements type
$(currentView)
  .find()
  .not("relationship")
  .each(function (e) {
    typesList.push(e.type);
  });

// // Also collect relationship types from the current view
// $(currentView)
// .find("relationship")
// .each(function (r) {
//   typesList.push(r.type);
// });

typesList.sort(function (a, b) {
  var textA = a.toUpperCase();
  var textB = b.toUpperCase();
  return textA < textB ? -1 : textA > textB ? 1 : 0;
});

// Remove duplicates from the array
typesList = typesList.filter(onlyUnique);

// Remove from array types which are not concerned by the legend
typesList = typesList.filter(function (item) {
  return excludedTypes.indexOf(item) === -1;
});

// For each type found in the view
for (var i = 0; i < typesList.length; i++) {
  // Search the corresponding standard element to be used for legend purpose
  theConcept = $("." + prefix + typesList[i]).first();
  if (!theConcept) {
    var theConcept = model.createElement(typesList[i], prefix + typesList[i]);
    theConcept.prop("Object State", groupName);
  }
}

$("element").each(function(e) {
  console.log(e.type)
})

// Create the group with a default size and position
var legendGroup = currentView.createObject("group", x, y, 10, 10, true);
legendGroup.name = groupName;
y += 30;
groupHeight += 30;

for (var i = 0; i < typesList.length; i++) {
  pictogram = $("." + prefix + typesList[i]).first();

  // Update the group width and height to ensure autonesting will work
  legendGroup.bounds = { width: groupWidth, height: groupHeight };

  // Add the concept sized specifically to illustrate pictogram, and a note to bear the text, both with autonesting
  var object = currentView.add(
    pictogram,
    pictogram_x,
    y,
    default_width,
    default_height,
    true
  );

  var currentNote = currentView.createObject(
    "note",
    pictogram_x + label_x,
    y,
    label_width,
    default_height,
    true
  );

  currentNote.setFigureType(noteFigureType);
  currentNote.opacity = noteOpacity;
  currentNote.outlineOpacity = noteOutlineOpacity;
  currentNote.text = typesList[i][0].toUpperCase() + typesList[i].slice(1);

  y += 40;
  groupHeight += 40;
}

console.log("> Ending properly");

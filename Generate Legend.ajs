//
// Generate diagram legend
//
// For a selected view, create a group named 'Legend', in which will be nested for each concepts type found in view
// - a concept, specifically sized to show the pictogram
// - a note, to be used to name or explain the concept specifically in the view, hence preventing to rename the concept
// That way,
// - a model will be a bit polluted but with a specific set of concepts, for legend purpose, prefixed so easily identifiable
// - the same set can be used in multiple views, multiples legends as the associated text is set in a side note
//
// Roadmap:
// - ask to delete an existing group name 'Legend' before create a new group
// - improve typesList cleaning (removing types not concerned by legend) to avoid adding an exception
//

var x = 10;
var y = 10;
var default_width = 50;
var default_height = 30;
var typesList = [];
var pictogram_x = x + 10;
var label_x = x + pictogram_x + 30;
var label_width = default_width + 80;
var groupWidth = 10 + default_width + 10 + label_width + 10;
var groupHeight = default_height + y;
var prefix = "legend-purpose-";
var groupName = "Legend";
var noteFigureType = 0;
var transparentFigureType = 1;
var noteOpacity = 0;
var noteOutlineOpacity = 0;
var emptyLabel = ""
var selectedFolder = ""

// Folders to be created if not exist
var businessFolder, 
    strategyFolder,
    applicationFolder,
    technologyFolder,
    motivationFolder,
    implementationFolder,
    otherFolder,
    relationsFolder;

// Types to exclude from the legend
var excludedTypes = [
  "diagram-model-group",
  "diagram-model-note",
  "diagram-model-connection",
  "archimate-diagram-model"
];

console.show();
console.clear();
console.log("> Generate diagram legend:");

function onlyUnique(value, index, self) {
  return self.indexOf(value) === index;
}

// Detemine the layer for a given type
function getLayerForType(type) {
  if (type.startsWith("business-")) return "Business";
  if (type.startsWith("application-")) return "Application";
  if (type.startsWith("technology-") || type.startsWith("device") || type.startsWith("node")) return "Technology & Physical";
  if (type.startsWith("strategy-")) return "Strategy";
  if (type.startsWith("motivation-") || type.startsWith("value")) return "Motivation";
  if (type.startsWith("implementation-")) return "Implementation & Migration";
  return "Other";
}

// Generate a folder if it does not exist
function generateFolder(parentFolder, nameSuffix) {
  var folderName = parentFolder.name + " " + nameSuffix;
  var existing = $("folder." + folderName).first();
  if (!existing) {
    var newFolder = parentFolder.createFolder(folderName);
    newFolder.prop("Object State", groupName);
    return newFolder
  }
}


var currentView = $(selection).filter("archimate-diagram-model").first();
if (!currentView) {
  console.log("> No view identified: exiting.");
  exit();
}

// Add the names of the folders
businessFolder = $("folder.Business").first();
strategyFolder = $("folder.Strategy").first();
applicationFolder = $("folder.Application").first();
technologyFolder = $("folder.Technology & Physical").first();
motivationFolder = $("folder.Motivation").first();
implementationFolder = $("folder.Implementation & Migration").first();
otherFolder = $("folder.Other").first();
relationsFolder = $("folder.Relations").first();

// Go through each folder type
generateFolder(businessFolder, groupName);
generateFolder(strategyFolder, groupName)
generateFolder(applicationFolder, groupName)
generateFolder(technologyFolder, groupName)
generateFolder(motivationFolder, groupName)
generateFolder(implementationFolder, groupName)
generateFolder(otherFolder, groupName)
generateFolder(relationsFolder, groupName)

// Loop through all elements used in selected view and push into array elements type
$(currentView)
  .find()
  .not("relationship")
  .each(function (e) {
    typesList.push(e.type);
  });

// // Also collect relationship types from the current view
// $(currentView)
// .find("relationship")
// .each(function (r) {
//   typesList.push(r.type);
// });

typesList.sort(function (a, b) {
  var textA = a.toUpperCase();
  var textB = b.toUpperCase();
  return textA < textB ? -1 : textA > textB ? 1 : 0;
});

// Remove duplicates from the array
typesList = typesList.filter(onlyUnique);

// Remove from array types which are not concerned by the legend
typesList = typesList.filter(function (item) {
  return excludedTypes.indexOf(item) === -1;
});

// For each type found in the view
for (var i = 0; i < typesList.length; i++) {
  // Search the corresponding standard element to be used for legend purpose
  theConcept = $("." + prefix + typesList[i]).first();
  if (!theConcept) {
    var theConcept = model.createElement(typesList[i], prefix + typesList[i]);
    theConcept.prop("Object State", groupName);
    
    if (theConcept) {
      selectedFolder = $("folder").filter(function(f) {
        return f.name === getLayerForType(theConcept.type) + " Legend";
      }).first();
      selectedFolder.add(theConcept);
    }
  }
}

// $("element").each(function(e) {
//   console.log(e.type)
// })

// Create the group with a default size and position
var legendGroup = currentView.createObject("group", x, y, 10, 10, true);
legendGroup.name = groupName;
y += 30;
groupHeight += 30;


// Create elements for each type found in the view
for (var i = 0; i < typesList.length; i++) {
  pictogram = $("." + prefix + typesList[i]).first();

  // Update the group width and height to ensure autonesting will work
  legendGroup.bounds = { width: groupWidth, height: groupHeight };

  // Add the concept sized specifically to illustrate pictogram, and a note to bear the text, both with autonesting
  var object = currentView.add(pictogram, pictogram_x, y, default_width, default_height, true);
  var currentNote = currentView.createObject("note", pictogram_x + label_x, y, label_width, default_height, true);

  currentNote.setFigureType(noteFigureType);
  currentNote.opacity = noteOpacity;
  currentNote.outlineOpacity = noteOutlineOpacity;
  currentNote.text = typesList[i][0].toUpperCase() + typesList[i].slice(1);

  y += 40;
  groupHeight += 40;
}

// Create relationship legend
var allRelationships = model.find("relationship");

allRelationships.forEach(function(rel) {
  var legLeftAnchorName = "legend-anchor-left-" + rel.type;
  var legRightAnchorName = "legend-anchor-right-" + rel.type;

  // Check if a legend relationship with these anchors already exists
  var alreadyExists = $("relationship").filter(function(r) {
    return r.source && r.target &&
           r.source.name === legRightAnchorName &&
           r.target.name === legLeftAnchorName &&
           r.type === rel.type;
  }).first();

  if (alreadyExists) {
    console.log("Legend already exists for: " + rel.type);
    return; // Skip this one
  }
    legendGroup.bounds = { width: groupWidth + 20, height: groupHeight };

    // Create transparent grouping element 1 (left side of relationship)
    var groupingElement = model.createElement("grouping", legLefttAnchorName);
    // selectedFolder = $("folder.Other Legend").first();
    var selectedFolder = $("folder").filter(function(f) {
      return f.name === "Other Legend";
    }).first();
    selectedFolder.add(groupingElement);
    var groupingViewObject = currentView.add(groupingElement, pictogram_x, y + 12, 1, 1, true);
    groupingViewObject.setFigureType(transparentFigureType);
    groupingViewObject.outlineOpacity = noteOpacity;

    // Create transparent grouping element 2 (right side of relationship)
    var rightElement = model.createElement("grouping", legRightAnchorName);
    selectedFolder.add(rightElement);
    rightElement
    var rightView = currentView.add(rightElement, pictogram_x + 48, y + 12, 1, 1, true);
    rightView.setFigureType(transparentFigureType);
    rightView.outlineOpacity = noteOpacity;

    // Create relationship between the two dummy elements
    var legendRel = model.createRelationship(rel.type, "", groupingElement, rightElement);
    // selectedFolder = $("folder.RelationsLegend").first();

    var selectedFolder = $("folder").filter(function(f) {
      return f.name === "Relations Legend";
    }).first();
    selectedFolder.add(legendRel);
    legendRel.prop("Object State", groupName);
    var visualRel = currentView.add(legendRel, groupingViewObject, rightView);

    // Add a note to describe the relationship type
    var note = currentView.createObject("note", pictogram_x + label_x, y, label_width + 20, default_height, true);
    note.setFigureType(noteFigureType);
    note.opacity = noteOpacity;
    note.outlineOpacity = noteOutlineOpacity;
    note.text = rel.type.charAt(0).toUpperCase() + rel.type.slice(1);

    y += 40;
    groupHeight += 40;
  });

console.log("> Ending properly");
